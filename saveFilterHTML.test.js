const fs = require('fs');
const { saveFilterHTML } = require('./function/subsidiary/deleteAllScaner');

describe('saveFilterHTML', () => {
  it('должен создать новый файл с отфильтрованным контентом', (done) => {
    const pathFile = '/media/andrey/project/project/servers/SERVER-node-chatGPT/rootDocument/ChatGPT _ ChatGPT 4o Free _ Support all countries.html';
    
    const pathFileNew = '/media/andrey/project/project/servers/SERVER-node-chatGPT/test/C2.html';
   
    // const targetTexts = [
//     'как в текстовом фармате обозначется перенос на следующую строку,',
//     'На node js например у меня есть переменнаяя text = "привет мир", ее надо записать в файл и между словами привет и мир поставить знак разделитель',
//     '. Используя fs.writeFile (простой, но не подходит для больших файлов): Почему неподходит и какой критерий большого файла конкретно в размерах',
//     'могу ли я в сепаратор записать \\n',
//     'Ты пишишь что во всех операционых системах знак переноса разный, но как тогда они открываются в разных системах. Например я создал файл под линуксом текстовый с переносом но он открывается замечательно и в виндоус редакторе',
//     'Есть длинная строка которая может быть с любым количеством символов. Нужно написать функцию на node чтоб она перебирала эту строку и через 70 символов в стреченый пробел заменяла знаком переноса от линукс системы.Возвращаемая строка должна быть с переносами',
//     'мне кажится алгоритм немного запутаный давай попробуеме по другому у нас есто некие переменые start и end когда мы начинаем перебирать строку мы имеем start=0 считаем 70 символов и после этого идем далее и ищем пробел. Если пробе найден фиксируем это как конечную точку и копируем строку от позиции start до этой точки в масив. В следующем просчоте start станет точкой которуюя мы нашли а новая опять высчитается . Таким образом мы собирем в масив из строк которые будут больше 70 . Потом останется только собрать все элементы масива поставив знак переноса. Мне кажится этот код легче отлаживать в случии каких то не учтных ошибок. Мы будем иметь масив выписаных кусков который можим посмотреть',
//     'добавь если нужна закругка модулей, и сделай документацию к функции в виде коментария',
//     'та не понял про модули, все перепиши срипт оставь как был, модули загрузки в ноде если нужны рекваер'
// ];
   
    const targetTexts = [
      'как в текстовом ',
      'На node js например у меня '
    ];

    // Вызываем функцию
    saveFilterHTML(pathFile, pathFileNew, targetTexts);

    // Проверяем, создан ли новый файл
    fs.access(pathFileNew, fs.constants.F_OK, (err) => {
      expect(err).toBeNull(); // Проверяем, что нет ошибки (файл существует)

      // Дополнительные проверки (по желанию)
      // Например, можно прочитать содержимое нового файла и проверить, содержит ли оно ожидаемый контент

      if (!err) {
        fs.readFile(pathFileNew, 'utf8', (err, data) => {
          expect(err).toBeNull(); // Проверяем отсутствие ошибок при чтении
          expect(data).toBeDefined(); // Проверяем, что данные прочитаны

          // Здесь можно добавить дополнительные проверки, например,
          // expect(data).toContain('ожидаемый текст');

          done(); // Сообщаем Jest, что тест завершен
        });
      } else {
        done(err); // Сообщаем Jest об ошибке
      }
    });
  });

  // Дополнительные тесты (по желанию)
  // Например, можно проверить, что функция правильно обрабатывает ошибки,
  // если исходный файл не существует, или если целевой файл не может быть создан.
});
    
   